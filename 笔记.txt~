1:《更强大的滚动控件-RecyclerView》
listView弊端:
不得不使用特殊的技巧来提升他的运行效率，listView性能很差;
listView扩展性不好，只能实现纵向滚动效果，做不到实现横向滚动效果
RecyclerView的基本用法:
a:需要在build.gradle中添加相应的依赖库才行

注意:RecyclerView并不是内置在系统的SDK当中，所以需要把完整的包路径写出来。
import android.support.v7.widget.RecyclerView;

b:横向滚动：
在item中将layout变成: android:orientation="vertical"
在Activity中添加: lm.setOrientation(LinearLayoutManager.HORIZONTAL);

c:瀑布流布局：
StaggeredGridLayoutManager可用于实现瀑布流布局，为了将不同的icon宽度凸显出来使用了getRandomLengthName方法

RecyclerView的点击事件
需要自己的子项具体的View去注册点击事件(可以分别从具体的控件开始进行点击操作和整体view的点击操作)

---------------------------------------------------------------------------------------
Nine-Patch 图片
能够指定哪些区域可以被拉伸，哪些区域不可以。
上边框和左边框绘制部分表示当图片需要拉伸时就拉伸黑点标记区域;
右边框和下边框绘制部分表示内容会被放置的区域。
---------------------------------------------------------------------------------------
手机平板要兼顾
Fragment是可以嵌入在活动中的UI片段，可以让程序更加充分合理的利用大屏幕空间，因而在平板上应用的很广泛。
两个不同包名下的Fragment,一个是系统内置的android.app.Fragment，一个是support-v4库中的android.support.v4.app.Fragment(用这个)因为它可以让Fragment在所有Android系统版本中功能保持一致～

使用：
使用<fragment>标签布局需要指定android.name属性来显示指明要添加的Fragment类名，包名加类名

注意：
在activity.xml中引用fragment.xml的时候使用属性<fragment>必须指明id
 

Framelayout是一种最简单的布局，所有控件默认会摆放在布局的左上角

另一种注册点击事件的方法：
implements View.OnClickListener{
    @Override
    public void onClick(View view) {
        switch (view.getId()){
            case R.id.button:
                replaceFragment(new AnotherRightFragment());
                break;
            default:
                break;
        }
    }
}

动态加载Fragment
1:创建待添加的碎片实例(AnotherRightFragment)
2:获取FragmentManager,在Activity中可以直接使用getSupportFragmentManager()方法得到
3:开启一个FragmentTransaction ,通过beginTransaction开启
4:向transaction中添加或替换Fragment,一般使用replace方法，需参数1容器id,参数2Fragment对象实例
5:调用commit()方法来完成。

调用replaceFragment(new RightFragment());
具体实现:
    private void replaceFragment(Fragment fragment){
        FragmentManager fm = getSupportFragmentManager();
        FragmentTransaction transaction = fm.beginTransaction();
        transaction.replace(R.id.right_layout,fragment);
        transaction.commit();
    }

1:Activity中获取 Fragment
在Activity中获取Fragment的实例:
//这个id=right_fragment是在activity_layout中的id
RightFragment rightFragment = (RightFragment)getSupportFragmentManager().findFragmentById(R.id.right_fragment);
//这样获得Fragment的实例就可以获得Fragment中的的方法了

2:在Fragment中调用Activity
2.1:先获得Activity在Fragment中的实例
MainActivity activity = (MainActivity)getActivity();

3:Fragment与Fragment通信
Fragment -> Activity ->Fragment
---------------------------------------------------------------------------------------
Fragment的生命周期
Activity中的回调方法Fragment都有除此之外还有一些附加的回调方法
1:onAttach() -> 当Fragment与Activity建立关联时候调用
2:onCreateView() -> 为Fragment创建视图(加载布局)时调用
3:onActivityCreated() -> 确保与Fragment相关连的Activity已经创建完毕
4:onDestroyView() -> 与Fragment相关连的视图被移除时调用
5:onDetach() -> 当Fragment与Activity解除关联的时候调用 
---------------------------------------------------------------------------------------
动态加载布局技巧
使用限定符->程序能够根据设备的分辨率或屏幕大小在运行时来决定加载哪个布局
比如在res 文件中添加文件layout-large
当是平板时候选用layout-large路径下的
当时手机设备时候选用layout路径下的
---------------------------------------------------------------------------------------
同时兼容手机和平板的应用程序
步骤1:首先创建一个新闻内容的布局 -> news_content_frag.xml 头部有标题有内容
步骤2:创建类NewsContentFragment引用刚才的布局news_content_frag.xml
Fragment都是在onCreateView函数中进行引用的

步骤3:创建单页模式类NewsContentActivity，同时搭配布局news_content.xml,这个布局引用news_content_frag.xml

步骤4:创建用于显示新闻列表的布局，news_title_frag.xml，是一个RecyclerView及其子布局news_item.xml
步骤5:用于展示新闻列表的地方->NewsTitleFragment.java
没一个Fragment都是在onCreateView中将xml引入进来的，同时将news_title_frag.xml中的控件RecyclerView的数据填充进去

步骤6:创造双页模式界面
使用限定符在layout-sw600dp文件夹下同样创建一个activity_mail.xml,只有这个布局中才有;

步骤7:为RecyclerView写一个Adapter
这个adapter可以是一个独立类也可以是内部类
实现Adapter步骤
7.1:在onCreateViewHoler中注册点击事件
7.2:如果是双页就更新内容调用NewsContentFragment.refresh()，如果是单页就启动Activity
---------------------------------------------------------------------------------------
×××××××××××××××××××××××××××××××××××××××××××××××××××××
注意:
可以缓解视觉疲劳/可以不反光
可以吃东西不被阿姨发现
坐在做里面
需要有插座
带小老虎，带零食可以中午吃的那种
离打水的地方近一点/那一个超级大的水壶
带个小围巾
护手爽，没有护手爽
×××××××××××××××××××××××××××××××××××××××××××××××××××××
---------------------------------------------------------------------------------------
广播机制
在一个ip网络范围中，最大的ip地址是被用来保留作为广播地址使用的，比如某个网络的ip范围是192.168.0.xxx,子网掩码是255.255.255.0，那么这个广播地址就是192.168.0.255

目的:为了进行系统级别的消息通知，Android也引入了一套广播机制，Android中的广播机制会显得更加灵活，因为每个应用程序都可以对自己感兴趣的广播进行注册，只会收到自己所关心的内容，这个广播可以来自与系统也可以来自于其他应用程序

Android提供了一套完整的API用于自由的发送和接收广播

广播的类型:
标准型和有序型

标准广播是一种完全异步执行的广播，广播发出后，所有的广播接收器会在统一时刻接受到该广播消息，没有顺序可言，这种广播效率会比较高同时也意味着是无法被截断的

有序广播则是同步执行的广播，在广播发出后，同一时刻只有一个广播接收器会收到这个广播，当前这个广播接收器的逻辑执行完毕后，广播才会继续传播;所以广播接收器是有先后顺序的，优先级高的广播接收器可以先收到广播，前面的广播接收器会截断正在传递的广播


接收系统广播：
系统消息如:手机开机后会发送一条广播，电池电量发生变化也会发出一条广播等等，这些系统状态的信息

注册广播的方式有两种:
代码中注册是动态注册，在AndroidManifest中注册是静态注册

如何创建广播监听器:
新建一个类继承自BroadcastReceiver并重写夫类的onReceiver方法
---------------------------------------------------------------------------------------
判断当前是否有网络:
ConnectivityManager connectivityManager = (ConnectivityManager)getSystemService(Context.CONNECTIVITY_SERVICE);
NetworkInfo mNetworkInfo = connectivityManager.getActiveNetworkInfo();
if(mNetworkInfo != null && mNetworkInfo.isAvailable()){
Toast.makeText(context,"network is available",Toast.LENGTH_SHORT).show();
}else{
Toast.makeText(context,"network is not available",Toast.LENGTH_SHORT).show();
}
---------------------------------------------------------------------------------------
静态注册和动态注册的优劣势
动态注册可以灵活注册和取消注册但必须在程序启动后，因为监听是写在onCreate里的，如果想要在当前程序未启动的前提下就能接收到广播了呢？
使用静态注册


接收开机广播
AS快速创建一个BroadcastReceiver,右击包名-》new -》 other -》找到Boradcast, Exported 属性代表是否允许这个广播接收器接收本程序以外的广播;Enabled 属性代表是否启用这个广播接收器;而且使用AS创建的广播接收器会在AndroidManifest.xml中自动添加静态注册广播接收器


静态广播:
有action的需要在<receiver>中添加，有广播权限的也需要添加，比如开启权限
    <!-- 这个是监听系统开机广播的权限 -->
    <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"/>
这个写在<application>外面，和<application>并列    
    
    
这个写在<application>里面
<!-- 在application 的标签中出现除了Activity以外的标签-->
        <receiver
            android:name=".BootCompleteReceiver"
            android:enabled="true"
            android:exported="true">
            <!-- 当系统启动后会发出一条值为 android.intent.action.BOOT_COMPLETED的 action -->
            <intent-filter>
                <action android:name="android.intent.action.BOOT_COMPLETED"/>
            </intent-filter>
        </receiver>
---------------------------------------------------------------------------------------
注意:
onReceiver中不可添加过多的逻辑或进行耗时操作，因为广播中是不允许开线程的，广播接收器更多是扮演一种打开其他组件的角色比如创建一条状态栏通知或者启动一个服务等


---------------------------------------------------------------------------------------
之前说接收系统广播，现在说发送自定义广播 -》 在应用程序中发送自定义广播(发送标准广播和发送有序广播)
在发送广播前先定义广播接收器接收广播
Android8上使用自定义广播记得在发送时候添加
intent.setComponent(new ComponentName("com.broadcast.liuyixi.mybroadcastreceiver","com.broadcast.liuyixi.mybroadcastreceiver.MyBroadcastReceiver"));


AndroidDeveloper:
广播限制：除了有限的例外情况，应用无法使用清单注册隐式广播。 它们仍然可以在运行时注册这些广播，并且可以使用清单注册专门针对它们的显式广播

为啥？
特例除外隐式广播是不针对特定应用的广播，Android_O做了对隐式广播的限制。
---------------------------------------------------------------------------------------
在另一个程序中接收自定义的广播

发送有序广播还没实现，存疑
广播是可以跨进程的通信方式:比如它可以收到系统广播～

有序广播的优势是可以随时拦截广播的传递
---------------------------------------------------------------------------------------
本地广播
背景引出:
全局广播 -> 发出的广播可以被任何其他应用程序收到，我们也可以收到来自任何应用程序的广播，这样引发一个问题是可能被其他应用程序截获数据或者其他应用程序不停向我们广播接收器里发送各种垃圾广播

本地广播机制:在应用程序内部进行传递，而且广播接收器只能接收来自本应用程序发出的广播

本地广播是不能静态注册的，因为静态注册本来就是为了在应用程序未启动时也能收到广播，而发送本地广播时我们的应用程序已经启动了，因此不需要静态注册;


本地广播的优势:
不会数据泄密，不会有安全隐患，比全局广播更高效
---------------------------------------------------------------------------------------
广播的最佳实现:
将所有活动关闭的功能～
---------------------------------------------------------------------------------------
数据存储持久化技术
瞬时数据:存储在内存中，可能会因为程序关闭或其他原因导致内存被回收而数据丢失；
数据持久化指将内存中数据保存在存储设备中，保证即使在手机或电脑关机的情况下，这些数据仍不会丢失。保存在内存中的数据是瞬时状态，保存在存储设备中的数据是处于持久状态的，持久化提供一种机制可以让数据在瞬时状态和持久状态进行转换。

Android提供三种功能用于简单数据持久化功能，文件存储，SharedPreference 存储及数据库存储

文件存储:	
适用场景:存储一些简单的文本数据或二进制数据～
特点:
1：它不对存储的内容进行任何的格式化处理～所有数据都是原封不动地保存到文件中～
2：如果你想保存一些较复杂的文本数据，就需要定义一套自己的格式规范，这样方便之后的数据从文件中重新解析出来～

Context 类中提供一个openFileOutput()方法，用于将数据存储到指定的文件中，第一个参数是文件名，不包含路径，所有文件默认存储在/data/data/<package name>/files目录下；第二个参数是操作模式:
MODE_PRIVATE:表示当指定同样文件名的时候，所写入的内容会覆盖原文件中的内容～
和MODE_APPEND:表示如果该文件已存在，就往文件里面追加内容，不存在就创建新文件～
改方法是将数据保存在当前应用程序自己的file中
public void save(String inputText){
        FileOutputStream out = null;
        BufferedWriter writer = null;
        try {
            //1:得到一个FileOutputStream对象
            //openFileOutput将数据存储到指定的文件中
            out = openFileOutput("data", Context.MODE_PRIVATE);
            //构建一个OutputStreamWriter对象
            //再构建一个BufferedWriter对象
            writer = new BufferedWriter(new OutputStreamWriter(out));
            //然后通过BufferedWriter将inputText文本内容写到文件中
            writer.write(inputText);
        }catch (IOException e){
            e.printStackTrace();
        }finally {
            try{
                if(writer != null){
                    writer.close();
                }
            }catch (IOException e){
                e.printStackTrace();
            }
        }
    }
---------------------------------------------------------------------------------------
读取文件中的数据
openFileInput()方法，用于从文件中读取数据，接收一个参数，即要读取的文件名～然后会自动到/data/data/package name/files/目录中去加载这个文件，并返回一个FileInputStream对象，得到这个对象后再通过java流方式读取数据就好了

小技能
1:setSelection()方法将输入光标移动到文本的末尾位置，以便于继续数据
2:对字符串进行非空判断使用TextUtils.isEmpty(),它的优势是可以一次性进行两种空值判断，当传入的字符串为null或等于空字符串的时候，这个方法都会返回true

从文件中获取数据
    public String load(){
        FileInputStream in = null;
        BufferedReader read = null;
        StringBuilder content = new StringBuilder();
        try{
            //1:得到一个FileInputstream对象
            //它会在/data/data/<package name>/file路径下找这个文件
            in = openFileInput("data");
            read = new BufferedReader(new InputStreamReader(in));
            String line = "";
            while ((line = read.readLine()) != null){
                content.append(line);
            }
        }catch (IOException e){
            e.printStackTrace();
        }finally {
            if(read != null){
                try{
                    read.close();
                }catch (IOException e){
                    e.printStackTrace();
                }
            }
        }
        return content.toString();
    }
---------------------------------------------------------------------------------------
写数据
FileOutputStream out = null;
BufferedWriter writer = null;
out = openFileOutput("data", Context.MODE_PRIVATE);
writer = new BufferedWriter(new OutputStreamWriter(out));
writer.write(inputText);
记得close()
读数据
FileInputStream in = null;
BufferedReader read = null;
StringBuilder content = new StringBuilder();
in = openFileInput("data");
read = new BufferedReader(new InputStreamReader(in));
String line = "";
while ((line = read.readLine()) != null){
     content.append(line);
}
return content.toString();
---------------------------------------------------------------------------------------
第二种数据存储方式:
SharedPreferences存储
使用键值对的方式存储数据，当保存一条数据时候需要给数据提供一个对应的键，这样读取数据时候通过这个键把相应的值取出来～
SharedPreferences支持多种不同的数据类型

1：将数据存储到SharedPreferences中 
1.1:首先获得SharedPreferences对象，三种方式 Context类中getSharedPrefernces()方法 
1.2:Activity类中的getPreferences() 方法 
1.3:PreferenceManager类中的getDefaultSharedPreferences() 方法 

SharedPreferences是通过XML对数据进行管理的～

从SharedPreference中读取数据
---------------------------------------------------------------------------------------
第三种数据存储方法:SQLite数据库存储
1:轻量级关系型数据库，运算速度非常快，占用资源很少，通常只需要几百kb内存就足够了，SQLite不仅支持标准的SQL语法，还遵循ACID事务;

2:Android为了让我们更加方便的管理数据库，专门提供一个SQLiteOpenHelper帮助类，借助这个类可以对数据库进行创建和升级;

3:SQLiteOpenHelper是一个抽象类，使用的话需要自己创建自己的帮助类去继承它;
SQLiteOpenHelper中有两个抽象方法，分别是onCreate()和onUpdate(),我们在自己的帮助类中重写这两个方法，然后分别在这两个方法中去实现创建，升级数据库的逻辑。

4:SQLiteOpenHelper中有两个实例方法:getReadableDatabase()和getWritableDatabase();这两个方法作用:创建或打开一个现有的数据库(如果数据库已存在则直接打开，否则创建一个新的数据库)并返回一个可对数据进行读写操作的对象;不同的是当数据库不可写入的时候(如磁盘已满),getReadableDatabase()方法返回的对象将以只读的方式去打开数据库，而getWriteableDatabase()方法出现异常。
打开数据库
# sqlite3 BookStore.db 
查看表
#sqlite> .table
查看建表语句
#sqlite> .schema
退出
#sqlite> .exit
#sqlite> .quit
---------------------------------------------------------------------------------------




