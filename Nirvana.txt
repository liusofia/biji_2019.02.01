start with 07.18-07.19(周四\周五)
每次做题除了难度分组还有细分的难度分组
鼓励：坚持～执行力~
TODO:
	1:看看lintCode和leetCode什么区别呢~
	2:看看Android的概念和答案
	3:记得把新增的答案放在笔记里
------------------------------------------------------------------------
❤❤❤❤❤第一组：
	a.反转一个3位整数
	b.大小写转换
	c.大小写转换 II
	d.Getter与Setter
	e.在链表中找节点
❤❤❤❤❤第二组：
	a.链表的中点
	b.转换字符串到整数（容易版）
	c.三数之中的最大值
	d.合并排序数组 II
	e.矩阵面积
第三组：
	l a.整数排序
	l b.链表节点计数
	l c.简单计算器
	l d.链表转数组
	l e.交换数组两个元素
❤❤❤❤❤第四组：
	a.最高频率的IP(使用HashMap - 先获得～不符合就存起来～最后再获得符合要求的～) TODO理解一下为啥put进去是倒着的呢
	b.A + B 问题(递归)
	c.尾部的零(还是不太理解)(难\再琢磨)(搞不清什么时候用while,什么时候用for(String s:retString))
	d.斐波纳契数列(递归效率太低\有点绕\就是有点绕呢)
	e.计算圆周长和面积(数组的初始化int[] a = new int[2];)
√概念
A:封装：
	对象成员封装-private/public/protect;
	对类封装-一个java文件中有且只有一个类是public关键字;一个 ".java" 源文件可以有多个类但只能有一个public类，并且public类名必须与文件名相同
B:继承：
	extends表示继承关系－子类继承父类使用父类protected/public成员变量及方法，不能继承private成员变量和方法;
	子类和父类在同一个包下可以继承，否则不可以继承;
	对于子类可以继承的父类的成员变量：子类会隐藏屏蔽掉父类同名成员变量，如果子类中要访问同名父类成员变量需要使用super关键字;
	子类出现和父类同名成员方法称为覆盖(子类覆盖掉父类的成员方法，覆盖只针对非静态方法)，如在子类要访问父类的同名方法使用super关键字来进行引用;
super两种用法：
	1:super.成员变量/super.成员方法 用来在子类中调用父类的同名变量或同名方法
	2:子类构造中显示地调用父类的构造，并且是子类的第一句
C:构造：
	1:如父类构造都是带有参数的，则必须在子类构造中显示地通过super关键字调用父类的构造方法(并配以适当的参数列表)
	2:如果父类有无参构造，则子类构造中选择用super关键字调用父类，如子类不使用super调用,系统会自动调用父类的无参构造器
❤❤❤❤❤第五组：
	a.Excel表列序号 (这里肯定不用for增强循环呢)
	b.引用
	c.数组的最大值
	d.字符转整数
√概念
A)Java语言的优势:
	1:简单高效;
	2:java完全面向对象,除了基本数据类型外其他都作为类对象-代码大多体现了类机制,以类形式组织,由类来义对象的各种行为;
	3:平台无关性:一处编译处处执行,java程序编译成jvm的字节码，字节码独立于计算机的，当java程序在任意平台运行时，通过jvm的解释器对字节码进行解释执行;
	4:动态内存管理机制:自动垃圾回收,java无用内存利用空闲时间以线程方式在后台进行回收;
B)java与C++的区别:
	1:java有异常机制用于捕获异常，增强系统容错能力(C++没有);
	2:java无法让程序员使用指针访问，有利于java程序安全，避免了c++指针操作失误造成系统崩溃;
	3:数据类型及类：java完全面向对象，除了基本数据类型外其他都作为类对象；而c++允许将函数和变量定义为全局的;
第六组(2019.07.30)：
a.生成给定大小的数组
b.链表倒数第n个节点(典型~快慢指针归类的问题)
√概念
A:JRE和JDK的区别 
	JRE:java运行环境，包含java虚拟机，如要运行java程序安装jre就行 
	JDK:java开发工具包，开发工具包除了jre外还有java调试和分析工具 javaDoc;如果编写java程序安装jdk就行 
	JVM 是 Java 编程语言的核心。当我们运行一个程序时，JVM 负责将字节码转换为特定机器代码。JVM 也是平台特定的，并提供核心的 Java 方法，例如内存管理、垃圾回收和安全机制等
B:Java支持的数据类型有哪些？什么是自动拆装箱?
	java支持的八种数据类型是:short long byte int char float double boolean 
	自动装箱指：(基本数据类型)和(对象包装类型)间的转换(double -> Double/int ->Integer)
C:什么是值传递和引用传递
	对象被值传递代表传递对象的副本，改变对象副本不会影响对象本身；
	对象被引用传递，外部对对象的改变直接影响对象本身；
第七组(2019.07.31)：
a.翻转字符串中的单词(高频题)
b.翻转游戏(高频题)
c.排序数组中最接近元素(二分查找法/不是特别明白)
√概念
A:静态变量和实例变量
A1:静态变量前加关键字static而实例变量前则不加；
A2:实例变量属于对象属性，创建对象后实例变量才会被分配内存空间；静态变量为类属性，程序加载类字节码就会为静态变量分配内存空间；
A3:实例变量必须创建对象后才可以对这个对象来使用，静态变量则可直接使用类来进行使用

B:java创建对象的几种方式
B1:new 语句创建对象；
B2:反射：java.lang.reflect.Constructor 类的 newInstance() 实例方法
B3:调用对象的clone方法(在内存上对已存在对象的影印，就是不通过构造函数进行创建对象的)
第八组(2019.08.01)：
1：内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？
一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员
2：JDK 常用的 package
1:java.lang：系统的基础类，比如 String 等，这个包是唯一一个可以不用import就可以直接用的Package;
2:java.io: 所有输入输出有关的类，比如文件操作等.
3:java.net: 是与网络有关的类，比如 URL,URLConnection 等。
4:java.util: 系统辅助类，特别是集合类 Collection,List,Map 等。
3：方法覆盖 (Overriding) 和方法重载 (Overloading).
1:重载发生在同一个类里两个或多个同名不同参方法;
2:覆盖是子类重新定义父类的方法;覆盖必须有相同方法名,参数列表和返回类型．
3:构造函数不能被重写覆盖，但是可以被重载.
4：构造函数必须与类同名，但方法不能与类同名;
错误:普通方法可以和类名同名，和构造方法区别是构造方法没有返回值．
5：接口和抽象类的区别 
1:对子类而言,只能继承一个抽象类但却可以实现多个接口;
类实现一个接口必须实现接口中声明的所有方法，类如不实现抽象类声明的所有方法，在这种情况下类也必须得声明是抽象的
2:接口中的方法都是抽象的，而抽象类可以包含抽象方法和非抽象方法；

接口详细：
接口用于描述系统对外提供的所有服务,因此接口中的成员常量和方法都必须是公开的，确保外部使用者能访问他们；
接口不涉及具体细节，接口没有构造方法，不能被实例化，没有实例变量，只有静态变量
interface Door{
    void open();
    void close();
}
第九组(2019.08.02)：
a.第一个只出现一次的字符
b.Fizz Buzz 问题
概念：

1:Android的四大组件
这四种组件构成了Android应用的框架，然后由Intent联系这四种组件。
Activity用来显示Android的程序界面，一个应用往往有多个界面，所以一个应用中会有多个Activity。
Service没有界面的后台服务，会一直运行在后台。常被用来做数据处理，也可以做一些定时的任务。
Broadcast Receiver是Android的广播接收器，在广播机制中充当广播的接受者的作用，Android中充满了各种广播，所以需要有选择地接收一些有用的广播，然后处理这些广播。
ContentProvider可直译为内容提供者，它是用在不同的应用程序之间共享数据时，可以把一个应用的数据提供给其他的应用使用.

2:Handler机制
Handler机制原理是解决多线程并发，通过消息队列保证消息处理有先后顺序，Android提供一套更新UI的操作，所有更新UI的操作都在主线程中论循;
Looper:包含消息队列MessageQueue,所有Handler发送的消息都走消息队列；Looper.loop方法是一个死循环，有消息就处理，没消息就等待阻塞;
每一个线程只有一个looper,以先进先出的方式从消息队列中读取消息给Handler;
Handler消息的发送和处理，用在子线程中发送消息，在主线程处理并接受消息;
Message:消息对象，即Handler接收并处理的对象;

3.线程池的优势
降低消耗资源，通过重复利用已创建的线程降低线程创建和消耗;
提高相应速度，当任务到达时可以不需要等到线程创建就立即执行;
好管理，线程是稀缺资源，线程池可以统一分配调优;

创建线程方法：
ExecutorService singleThreadPool = Executors.newSingleThreadExecutor();
创建缓存线程池（重用先前的线程）
第十组(2019.08.06)
l 1: 嘿嘿嘿一遍
l 2: 去除重复元素
HashMap是无序的: key不允许有重复的，value可以有重复的
第十一组(2019.08.07)
1：最大子数组
2：单调数列
3：什么是ANR?如何避免？
Application not Responding; 应用程序一段时间内响应不灵敏，不同组件发生anr时间不一样，activity/service是5s;广播是10s;系统会向用户显示一个对话框，叫ANR;
解决：如访问网络和数据库，都要放到子线程中或者使用异步请求
4：Android数据存储方式有哪些？
文件存储、数据库存储、ShardPreference、ContentProvider
ShardPreference : Android提供的轻量级存储类，轻松存储数据和读取数据，特别适用于软件配置参数，可以保存简单的数据类型String、Integer、实现适用xml文件存放数据，文件存放在/data/data/<package name>/shared_prefs目录下
Content Provider:
适合于在不同应用间跨进程数据通信；
使用现有ContentProvider读取和操作相应程序中的数据；
创建自己的内容提供器为我们的程序提供外部访问的接口；
5：Android的安全机制
· Android中的每个应用都有自己的文件夹在data/data/包名下，该文件夹只有该应用访问其他应用访问无效
· Android有权限机制，在AndroidManifest.xml中进行声明；
· Android的代码混淆保护开发者劳动
第十二组(2019.08.08)
1：最后一个单词的长度
2：有效的括号序列
3：两个Activity之间跳转必然会执行哪些方法？
在A中跳转到B中会经历如下几个方法：
A的onCreate -> A的onStart -> A的onResume -> A的onPause B的onCreate -> B的onStart -> B的onResume 然后是A的onStop
如果B窗体是透明的或是对话框的则不会调用A的onStop方法；
4：多线程的两种创建方式
Thread类的实例是线程但它需要调用Runnable接口来执行，由于线程类本身就是 调用的Runnable接口；
所以我们可以继承Thread类或者直接实现Runnable接口来重写 run()方法实现线程。
5：单例模式
创建类的静态实例;私有构造函数；静态方法获取实例对象,饿汉模式；
public class Singleton{
	public static Singleton instance =  new Singleton();
	//创建类的静态实例
	private Singleton(){}
	//私有化构造函数
	public static Singleton getInstance(){
		return instance;
	}
	//公开静态方法获得实例
}
第十三组(2019.08.09)
1：落单的数(需要第二次循环)
2：主元素(使用HashMap方式怎么不行呢)
3：什么时候回导致内存泄露？
内存溢出的几点原因：
> a)资源释放问题:程序导致长期持有Context资源，IO引用等资源得不到释放造成内存泄露；
> b)对象内存过大:保存多个耗内存对象如XML、bitmap,造成内存超出限制；
> c)static关键字使用问题:static关键字修饰变量时，该变量属于类而不再属于类的实例，所以用static修饰的变量声明周期很长，避免引用Context
4：如何避免内存泄露OOM？
 对于图片使用记得及时回收Bitmap.recycle()，压缩图片大小；
 查询数据库长时间大量操作时及时关闭Cursor;
 在Activity的onPause()、onStop()、onDestroy()中适当释放资源；
5：什么是AIDL及如何使用？
 Android 接口定义语言实现跨进程通信；
 将服务的aidl放在src目录下，在gen目录下会生成相应的接口；
	通过bindService绑定服务，bindService中有ServiceConnc接口，覆写该类的onServiceConnected方法，该方法的第二个参数就是IBinder,通过IBinder对象可以跟远程进行通信；
-------------------------------------------------------------------------------------------
❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤每日记录
一、奇偶校验：
最高位b7为0代表一个字节中1的个数必须为奇数
b7为1代表一个字节中1的个数必须为偶数
48 = 0;57 = 9;
65 = A;90 = Z;
97 = a;122 = z;
常见ASCII码的大小规则：0~9<A~Z<a~z。
同字母---大写字母比小写字母要小32。如“A”<“a” 。
几个常见字母的ASCII码大小： “A”为65；“a”为97；“0”为 48

二、速度String < StringBuffer < StringBuilder
线程安全：String、StringBuffer 是不可改变的是不可继承的
线程不安全：StringBuilder　是可以改变的是可继承的所以是线程不安全的
应用场景:
String 应用于少量字符操作：
String类型的从后向前遍历for(s.length() - 1;I >= 0 ;i--)
StringBuffer　应用多线程大量数据
StringBuilder 应用单线程大量数据
String与String值相等比较用equals()方法，char与char值相等比较用”==”进行比较
--------------------------------------------------------------------------------------------:
07.22(周一)
链表:
链表是常见的基础数据结构,是线性表但不会线性的存储数据,并不像数组那样存储在在连续的内存中,而是在每一个节点里存储下一个节点的指针;

数组的特点:
查找效率高,插入和删除效率低;数组是静态的,初始化之后长度就不变了,数组容量不可改变;
length属性是针对数组的

链表的特点:
1:增加,删除元素时间复杂度是o(1);查找一个元素的时间复杂度是o(n);
2:单链表不会像数组那样预先分配存储空间大小,避免浪费空间;

ArrayList的特点
是一个动态数组类型，ArrayList对象既有数组的特征，也有链表的特征,ArrayList可以动态改变大小.
---------------------------------------------------------------------------------------------
07.23(周二)  
斐波那契的两种实现 
String to Integer两种方法 
--------------------------------------------------------------------------------------------
07.24(周三)
冒泡排序:
1:名字由来:越大的元素会经由交换慢慢"浮"到数列的顶端,故名~
2:原理:重复遍历需排序的数列,一次比较两个元素,如这两个数顺序错误就把他们交换过来,重复地遍历数列直到数列排序完成.
算法描述:
1:i从0开始, i 与 i+1 进行比较, 如果i> i+1 那么进行互换;
2:i不断增加直到i < n-1, (n是数组元素的个数,n-1是最后一个元素), 让数组元素中最大的元素在数组的最后面;

怎么算时间复杂度:
如果一个算法的执行次数是 T(n)，那么只保留最高次项，同时忽略最高项的系数后得到函数 f(n)，此时算法的时间复杂度就是 O(f(n)); 大O推导法。

switch 语句中变量类型可以是：
类型:byte、short、int 或者 char。从 Java SE 7 开始，switch 支持字符串 String 类型了，同时 case 标签必须为字符串常量或字面量;
注意:default 在没有 case 语句的值和变量值相等的时候执行。default 分支不需要 break 语句
--------------------------------------------------------------------------------------------
07.25(星期四)
1:二叉树-没有找到特直白简介的dd
2:数组交换的
3:HashMap 计算重复出现字符的

按位运算符专项:
1:按位"与"运算 - (&) :同'1'为'1',否则为0;
负数按补码形式参与按位"与"运算,a & b << 1 需要进位的地方并向左移位
特殊用途:清零 - 如果想将全部二进制位为0，只要与一个各位都为零的数值相与，结果为零

2:按位"或"|运算 - 有1为1 
 
3:"异或"^运算符:不同为1，相同为0 ,也叫"不进位加法运算符" 

4:左移运算符:<< 向左移 右边补零　
5:右移运算符:>> 向右移 正数左补零 负数左补一　
--------------------------------------------------------------------------------------------
07.25(星期五)
<<java概念>>: http://wiki.jikexueyuan.com/project/java-interview-bible/basic-concept.html
<<Andoird 概念>>：https://blog.csdn.net/feather_wch/article/details/52043153
阶乘定义:一个正整数阶乘是所有小于等于该数的正整数的积;
n!=1×2×3×...×n。阶乘亦可以递归方式定义：0!=1，n!=(n-1)!×n

length属性 - 针对数组;
length()方法 - 针对String字符串;
size()方法 - 针对泛型集合;
Math.pow(r,2) 等同于 r * r
十六进制:逢十六进一,使用有限的数字和符号代表所有数值.可使用数字符号的个数成为"基数"或"底数"
String.charAt() 制定索引范围内的字符
---------------------------------------------------------------------------------------------
2019.08.07
Backed by:在…的支持下
